var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = local_POD_overlap","category":"page"},{"location":"#local*POD*overlap","page":"Home","title":"localPODoverlap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for localPODoverlap.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [local_POD_overlap]","category":"page"},{"location":"#local_POD_overlap.RK4-NTuple{5, Any}","page":"Home","title":"local_POD_overlap.RK4","text":"RK4(u, x, t, dt, f)\n\nPerforms one time step of the 4th-order Runge-Kutta (RK4) integration method to solve an ordinary differential equation (ODE) of the form du/dt = f(u, x, t).\n\nArguments\n\nu: The current state vector at time t.\nx: Spatial grid points as a vector.\nt: Current time value.\ndt: Time step size.\nf: A function representing the system's dynamics (du/dt = f(u, x, t)).\nThe function f should accept three arguments: the state u, spatial variable x, and time t.\n\nReturns\n\nThe updated state vector after one time step using the RK4 method.\n\nExample Usage\n\n```julia u0 = [1.0, 0.0]   # Initial state x = [0.0, 1.0]    # Spatial grid t = 0.0           # Initial time dt = 0.01         # Time step f = (u, x, t) -> u # A simple dynamic system\n\nu_next = RK4(u0, x, t, dt, f)\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.compute_L2-Tuple{Any}","page":"Home","title":"local_POD_overlap.compute_L2","text":"compete_L2(a;average = True)\n\nCompute the L2-norm of a given vector or array.\n\nArguments\n\nn: Array of on any dimension.\naverage: Only compute the 2-norm along the first dimension\n\nReturns\n\nReturns the 2-norm of the entire array, treating it like a single vector.\n\nExample Usage\n\n```julia A = zeros(5,5) L2 = compute_L2(A,average = true) # Returns a vector of length 5 containing the L2-norm for each column of A\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.gen_ROM-Tuple{Any, Any, Any}","page":"Home","title":"local_POD_overlap.gen_ROM","text":"gen_ROM(x, snapshots, f; r=1, I=10, overlap=1, localize=true)\n\nGenerates a Reduced Order Model (ROM) based on provided snapshots and operator. This function can localize the basis functions to smaller regions of the domain and apply overlapping techniques for enhanced resolution.\n\nArguments:\n\nx: Spatial grid points as a vector.\nsnapshots: Matrix of snapshot data, where each column represents a state at a different time or parameter.\nf: Function used to generate the operator matrix A in the reduced model.\nr: (Optional) Number of modes to retain in the local SVD basis for each segment. Default is 1.\nI: (Optional) Number of subdomains or segments to divide the snapshot data into. Default is 10.\noverlap: (Optional) Number of overlapping rows between consecutive segments for localization. Default is 1.\nlocalize: (Optional) Boolean flag indicating whether or not to localize the basis. Default is true.\n\nReturns:\n\nA ROM_struct object containing the following fields:\nbasis: The full reduced basis matrix for the entire domain.\nlocal_basis: The localized basis matrix for individual subdomains.\nS: Gram matrix (inner product) of the basis functions.\nS_inv: Inverse of the Gram matrix S.\n_f_: Function to compute the reduced dynamics based on the reduced basis.\nP: Projection operator to project states onto the reduced space.\nA: Operator matrix in the reduced model.\np_A: Projected operator matrix (detailed in article).\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.gen_operator-Tuple{Any, Any, Any}","page":"Home","title":"local_POD_overlap.gen_operator","text":"gen_operator(x, f, basis)\n\nGenerates a linear operator matrix by applying a function f to the basis and transforming the result into a matrix form. This operator used in numerical simulations or transformations that involve a change of basis.\n\nArguments\n\nx: The input parameter(s) for the function f. Typically represents the spatial grid or other problem-specific variables.\nf: A function representing the system dynamics. It takes three arguments: the transformed basis*input, the variable x, and a scalar value 0 (for time).\nbasis: A matrix representing the basis vectors to which the operator will be applied.\n\nReturns\n\nlin_operator: A sparse matrix representing the linear operator in the given basis. The operator maps the system based on the function f.\n\nExample Usage\n\n```julia x = [1.0, 2.0]  # Example grid or input parameter basis = [1.0 0.0; 0.0 1.0]  # Identity basis f = (u, x, t) -> u  # Simple function returning the input vector\n\nlinoperator = genoperator(x, f, basis)  # Generates the linear operator matrix\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.gen_stencil-Tuple{Any, Any, Any}","page":"Home","title":"local_POD_overlap.gen_stencil","text":"gen_stencil(N,coeffs,positions)\n\nGenerate a sparse matrix operator of size (N,N) which can be applied to a vector of length N encoding a linear stenctil specified by a set of coefficients. Uses periodic boundary conditions.\n\nArguments\n\nN: Dimensionalty of desired operator\ncoeffs: Vector specifying the coefficients of the stencil\npositions: Vector specifying the index the coeficients should be placed at (0 corresponds to the main diagonal)\n\nReturns\n\nSparse matrix operator which encodes the linear stencil.\n\nExample Usage\n\n```julia N = 100 dx = 0.01 stencil = (1/dx^2) * [1,-2,1] positions = [-1,0,1] D = gen_stencil(10) # Diffusion operator of size (N,N)\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.interpolation_matrix-Tuple{Any, Any}","page":"Home","title":"local_POD_overlap.interpolation_matrix","text":"interpolation_matrix(x1, x2)\n\nGenerates a linear interpolation matrix M that maps values from grid x2 to grid x1. This matrix can be used to interpolate values between two grids based on their spacing.\n\nArguments\n\nx1: A 1D vector representing the new grid (target points).\nx2: A 1D vector representing the original grid (source points).\n\nReturns\n\nA sparse matrix M where each row corresponds to an interpolation from a point in x2 to its nearest points in x1, with linear interpolation weights applied to those points.\n\nExample Usage\n\n```julia x1 = [0.0, 0.5, 1.0, 1.5, 2.0]  # Target grid x2 = [0.0, 1.0, 2.0]  # Source grid M = interpolation_matrix(x1, x2)  # Creates the interpolation matrix\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.kernel-Tuple{Any}","page":"Home","title":"local_POD_overlap.kernel","text":"kernel(n)\n\nGenerates a kernel vector of length n based on a sine function raised to the power of 2. This is typically used in windowing operations or filtering applications, where the kernel shape is determined by the sine function.\n\nArguments\n\nn: The length of the kernel vector to be generated.\n\nReturns\n\nA vector of length n containing the kernel values generated by applying the sine function and squaring the result.\n\nExample Usage\n\n```julia k = kernel(10)       # Generates a kernel of length 10\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.simulation-NTuple{5, Any}","page":"Home","title":"local_POD_overlap.simulation","text":"simulation(u0, x, dt, T, f; F=0, save_every=1)\n\nPerforms a time-stepping simulation using the 4th-order Runge-Kutta method (RK4) to solve a system of differential equations. The simulation progresses from an initial state u0 to a final time T, with optional forcing and data saving at regular intervals.\n\nArguments\n\nu0: Initial condition vector of the system.\nx: Spatial grid or other problem-specific parameters.\ndt: Time step size for the simulation.\nT: Final time for the simulation.\nf: Function representing the system's dynamics (du/dt = f(u, x, t)).\nThe function f should accept three arguments: the state u, spatial variable x, and time t.\n\nKeyword Arguments\n\nF=0: Optional forcing term that will be added to the function f during the simulation.\nsave_every=1: Integer specifying how frequently to save data points. A value of 1 saves every time step.\n\nReturns\n\nus: A matrix where each column contains the state vector u at each saved time step.\ndus: A matrix where each column contains the rate of change of the state du/dt (from f(u,x,t)) at each saved time step.\nts: A vector containing the time points corresponding to the saved states.\n\nExample Usage\n\n```julia u0 = [1.0, 0.0]   # Initial condition x = [0.0, 1.0]    # Spatial grid dt = 0.01         # Time step size T = 1.0           # Final time f = (u, x, t) -> u # A simple dynamic system\n\nus, dus, ts = simulation(u0, x, dt, T, f; F=0.1, save_every=10)\n\n\n\n\n\n","category":"method"},{"location":"#local_POD_overlap.sparsify_matrix","page":"Home","title":"local_POD_overlap.sparsify_matrix","text":"sparsify_matrix(A; tolerance=1e-10)\n\nConverts a dense matrix A into a sparse matrix by zeroing out small elements below a given tolerance. The result is a sparse matrix representation, which can lead to significant memory savings for large matrices with many small or zero elements.\n\nArguments\n\nA: A dense matrix to be sparsified.\n\nKeyword Arguments\n\ntolerance=1e-10: A threshold below which matrix elements are considered zero. Only elements with absolute values greater than or equal to this tolerance are retained in the sparse matrix. The default tolerance is 1e-10.\n\nReturns\n\nA sparse matrix B where elements with absolute values less than the given tolerance have been set to zero.\n\nExample Usage\n\n```julia A = [1.0  0.000001; 0.0  5.0]  # A dense 2x2 matrix B = sparsify_matrix(A; tolerance=1e-6)   # Converts A to a sparse matrix with elements below 1e-6 zeroed out\n\n\n\n\n\n","category":"function"}]
}
