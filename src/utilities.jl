using LinearAlgebra
using SparseArrays

export sparsify_matrix, kernel, interpolation_matrix,compute_L2,gen_stencil


"""
sparsify_matrix(A; tolerance=1e-10)

Converts a dense matrix `A` into a sparse matrix by zeroing out small elements below a given tolerance. The result is a sparse matrix representation, which can lead to significant memory savings for large matrices with many small or zero elements.

# Arguments
- `A`: A dense matrix to be sparsified.

# Keyword Arguments
- `tolerance=1e-10`: A threshold below which matrix elements are considered zero. Only elements with absolute values greater than or equal to this tolerance are retained in the sparse matrix. The default tolerance is `1e-10`.

# Returns
- A sparse matrix `B` where elements with absolute values less than the given tolerance have been set to zero.

# Example Usage
```julia
A = [1.0  0.000001; 0.0  5.0]  # A dense 2x2 matrix
B = sparsify_matrix(A; tolerance=1e-6)   # Converts A to a sparse matrix with elements below 1e-6 zeroed out
"""
function sparsify_matrix(A,tolerance = 1e-10)
    B = spzeros(size(A))
    for i in 1:size(A)[1]
        for j in 1:size(A)[2]
            if abs(A[i,j]) >= tolerance
                B[i,j] += A[i,j]
            end
        end
    end
    return B
end



"""
kernel(n)

Generates a kernel vector of length `n` based on a sine function raised to the power of 2. This is typically used in windowing operations or filtering applications, where the kernel shape is determined by the sine function.

# Arguments
- `n`: The length of the kernel vector to be generated.

# Returns
- A vector of length `n` containing the kernel values generated by applying the sine function and squaring the result.

# Example Usage
```julia
k = kernel(10)       # Generates a kernel of length 10
"""
function kernel(n)
    eval = collect(1:n) .- 1/2
    return sin.(pi/(n)*eval).^(2)
end


"""
gen_operator(x, f, basis)

Generates a linear operator matrix by applying a function `f` to the `basis` and transforming the result into a matrix form. This operator used in numerical simulations or transformations that involve a change of basis.

# Arguments
- `x`: The input parameter(s) for the function `f`. Typically represents the spatial grid or other problem-specific variables.
- `f`: A function representing the system dynamics. It takes three arguments: the transformed `basis*input`, the variable `x`, and a scalar value `0` (for time).
- `basis`: A matrix representing the basis vectors to which the operator will be applied.

# Returns
- `lin_operator`: A sparse matrix representing the linear operator in the given basis. The operator maps the system based on the function `f`.

# Example Usage
```julia
x = [1.0, 2.0]  # Example grid or input parameter
basis = [1.0 0.0; 0.0 1.0]  # Identity basis
f = (u, x, t) -> u  # Simple function returning the input vector

lin_operator = gen_operator(x, f, basis)  # Generates the linear operator matrix
"""
function gen_operator(x,f,basis)
    input = zeros(size(basis)[2])
    dims = size(basis)[2]

    lin_operator = spzeros(dims,dims)

    mat = inv([[1,2];;[1,4]])

    for i in 1:dims
        input = 0*input
        input[i] += 1
        output1 = (basis' * f(basis*input,x,0))
        input[i] += 1
        output2 = (basis' * f(basis*input,x,0))
        for h in 1:dims
            if output1[h] != 0
                a,b = mat * [output1[h],output2[h]]
                lin_operator[h,i] = a
                #@assert b == 0
            end
        end
    end
    return lin_operator
end


function index_converter(i,I)
    index = mod(i,I)
    if index == 0
        index = I
    end
    return index
end

"""
interpolation_matrix(x1, x2)

Generates a linear interpolation matrix `M` that maps values from grid `x2` to grid `x1`. This matrix can be used to interpolate values between two grids based on their spacing.

# Arguments
- `x1`: A 1D vector representing the new grid (target points).
- `x2`: A 1D vector representing the original grid (source points).


# Returns
- A sparse matrix `M` where each row corresponds to an interpolation from a point in `x2` to its nearest points in `x1`, with linear interpolation weights applied to those points.

# Example Usage
```julia
x1 = [0.0, 0.5, 1.0, 1.5, 2.0]  # Target grid
x2 = [0.0, 1.0, 2.0]  # Source grid
M = interpolation_matrix(x1, x2)  # Creates the interpolation matrix
"""
function interpolation_matrix(x1,x2)
    h1 = x1[2] - x1[1]
    h2 = x2[2] - x2[1]
    M = spzeros(size(x1)[1],size(x2)[1])
    for i in 1:size(x1)[1]
        index = (x1[i]+x2[1])/h2
        fl = floor(Int,index)
        ce = ceil(Int,index)
        if fl-ce == 0
            weight = 1
        else
            weight = index - fl
        end
        M[i,index_converter(fl,size(x2)[1])] = 1-weight
        M[i,index_converter(ce,size(x2)[1])] = weight
    end
    return M
end

"""
compete_L2(a;average = True)

Compute the L2-norm of a given vector or array.

# Arguments
- `n`: Array of on any dimension.
- `average`: Only compute the 2-norm along the first dimension

# Returns
- Returns the 2-norm of the entire array, treating it like a single vector.

# Example Usage
```julia
A = zeros(5,5)
L2 = compute_L2(A,average = true) # Returns a vector of length 5 containing the L2-norm for each column of A
"""
function compute_L2(a;average = true)
    if average
        return mean(sqrt.(sum(a.^2,dims = 1)))
    else
        return sqrt.(sum(a.^2,dims = 1))
    end
end

"""
gen_stencil(N,coeffs,positions)

Generate a sparse matrix operator of size (N,N) which can be applied to a vector of length `N` encoding a linear stenctil specified by a set of coefficients. Uses periodic boundary conditions.

# Arguments
- `N`: Dimensionalty of desired operator
- `coeffs`: Vector specifying the coefficients of the stencil
- `positions`: Vector specifying the index the coeficients should be placed at (0 corresponds to the main diagonal)

# Returns
- Sparse matrix operator which encodes the linear stencil.

# Example Usage
```julia
N = 100
dx = 0.01
stencil = (1/dx^2) * [1,-2,1]
positions = [-1,0,1]
D = gen_stencil(10) # Diffusion operator of size (N,N)
"""
function gen_stencil(N,coeffs,positions)
    mat = spzeros((N,N))
    stencil_width = size(coeffs)[1]
    for i in 1:N
        for j in 1:stencil_width
            mat[i,index_converter(i+positions[j],N)] = coeffs[j]
        end
    end
    return mat
end
